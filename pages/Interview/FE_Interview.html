<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试基础丶 | 郑天霸的技术博客丨🥩</title>
    <meta name="description" content="温故而知新丶">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.e93f68ab.css" as="style"><link rel="preload" href="/assets/js/app.bcb09fd0.js" as="script"><link rel="preload" href="/assets/js/2.0cae008b.js" as="script"><link rel="preload" href="/assets/js/15.87afaf84.js" as="script"><link rel="prefetch" href="/assets/js/10.63c0acae.js"><link rel="prefetch" href="/assets/js/11.57e0b600.js"><link rel="prefetch" href="/assets/js/12.d767401c.js"><link rel="prefetch" href="/assets/js/13.66e92235.js"><link rel="prefetch" href="/assets/js/14.8ca2aee5.js"><link rel="prefetch" href="/assets/js/16.e4fe40bd.js"><link rel="prefetch" href="/assets/js/17.939329e7.js"><link rel="prefetch" href="/assets/js/18.a5366e53.js"><link rel="prefetch" href="/assets/js/19.b5bb1afe.js"><link rel="prefetch" href="/assets/js/20.2d36523b.js"><link rel="prefetch" href="/assets/js/21.783ed357.js"><link rel="prefetch" href="/assets/js/22.e829723c.js"><link rel="prefetch" href="/assets/js/23.0ecce0bb.js"><link rel="prefetch" href="/assets/js/24.20459581.js"><link rel="prefetch" href="/assets/js/25.67825afb.js"><link rel="prefetch" href="/assets/js/26.e229e374.js"><link rel="prefetch" href="/assets/js/27.ecd2a693.js"><link rel="prefetch" href="/assets/js/28.06ecb901.js"><link rel="prefetch" href="/assets/js/29.db38e244.js"><link rel="prefetch" href="/assets/js/3.6f5f7539.js"><link rel="prefetch" href="/assets/js/30.dee63892.js"><link rel="prefetch" href="/assets/js/31.2ccbf654.js"><link rel="prefetch" href="/assets/js/32.858cb50e.js"><link rel="prefetch" href="/assets/js/33.f944ee83.js"><link rel="prefetch" href="/assets/js/34.d80b4586.js"><link rel="prefetch" href="/assets/js/35.3fb235c5.js"><link rel="prefetch" href="/assets/js/36.b9a9142d.js"><link rel="prefetch" href="/assets/js/37.b88d2512.js"><link rel="prefetch" href="/assets/js/4.a9af6ba7.js"><link rel="prefetch" href="/assets/js/5.273e332d.js"><link rel="prefetch" href="/assets/js/6.bc1d42cb.js"><link rel="prefetch" href="/assets/js/7.b763d486.js"><link rel="prefetch" href="/assets/js/8.d8445f88.js"><link rel="prefetch" href="/assets/js/9.7efe41b9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e93f68ab.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">郑天霸的技术博客丨🥩</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/Xanadu-zxl" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://juejin.im/user/5b1228ccf265da6e0b6ff25e" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/Xanadu-zxl" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://juejin.im/user/5b1228ccf265da6e0b6ff25e" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>📐 CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/CSS/cssWorld.html" class="sidebar-link">📏 Css世界</a></li><li><a href="/pages/CSS/cssBasis.html" class="sidebar-link">📏 Css知多少丶</a></li><li><a href="/pages/CSS/Less.html" class="sidebar-link">📏 Less</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>🔫 Frame</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Frame/React.html" class="sidebar-link">⛳ React起飞</a></li><li><a href="/pages/Frame/Vue.html" class="sidebar-link">⛳ Vue起飞</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>🖇 HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/HTML/H5_CSS3.html" class="sidebar-link">📎 H5 and CSS3</a></li><li><a href="/pages/HTML/HTML.html" class="sidebar-link">📎 HTML复习</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>📪 HTTP</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/HTTP/http.html" class="sidebar-link">HTTP协议丶</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>💻 JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/JavaScript/Ajax-Json.html" class="sidebar-link">🍦 AJ</a></li><li><a href="/pages/JavaScript/Arrow.html" class="sidebar-link">🍦 箭头函数</a></li><li><a href="/pages/JavaScript/ES6.html" class="sidebar-link">🍦 ES6</a></li><li><a href="/pages/JavaScript/JavaScript.html" class="sidebar-link">🍦 JS基础丶</a></li><li><a href="/pages/JavaScript/Jquery.html" class="sidebar-link">🍦 Jquery</a></li><li><a href="/pages/JavaScript/JS_Advance.html" class="sidebar-link">🍦 JS进阶</a></li><li><a href="/pages/JavaScript/JS_Design_Mode.html" class="sidebar-link">🍦 JS设计模式</a></li><li><a href="/pages/JavaScript/JS_Object.html" class="sidebar-link">🍦 JS面向对象</a></li><li><a href="/pages/JavaScript/JS_RegExp.html" class="sidebar-link">🍦 JS正则</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>🎋 Node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Node/Node.js.html" class="sidebar-link">💣 Node.js</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>🎏 Interview</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Interview/FE_Interview.html" class="active sidebar-link">🐷 前端面试技巧</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#技术栈" class="sidebar-link">技术栈</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#页面布局" class="sidebar-link">页面布局</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#css盒模型" class="sidebar-link">CSS盒模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#两种模型区别" class="sidebar-link">两种模型区别</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#js如何设置获取盒模型对应的宽和高" class="sidebar-link">JS如何设置获取盒模型对应的宽和高</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#bfc" class="sidebar-link">BFC</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#创建bfc" class="sidebar-link">创建BFC</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#应用场景" class="sidebar-link">应用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#dom事件" class="sidebar-link">DOM事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#dom事件的级别" class="sidebar-link">dom事件的级别</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#dom事件模型" class="sidebar-link">dom事件模型</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#dom事件流" class="sidebar-link">dom事件流</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#dom事件捕获流程" class="sidebar-link">dom事件捕获流程</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#event对象的常见应用" class="sidebar-link">Event对象的常见应用</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#自定义事件" class="sidebar-link">自定义事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#http协议" class="sidebar-link">HTTP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#主要特点" class="sidebar-link">主要特点</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#http报文的组成部分" class="sidebar-link">HTTP报文的组成部分</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#http方法" class="sidebar-link">HTTP方法</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#get和push区别" class="sidebar-link">GET和PUSH区别</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#状态码" class="sidebar-link">状态码</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#指示信息-表示请求收到-继续处理" class="sidebar-link">指示信息--表示请求收到,继续处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#持久链接" class="sidebar-link">持久链接</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#管线化" class="sidebar-link">管线化</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#原型链" class="sidebar-link">原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#创建对象的三种方法" class="sidebar-link">创建对象的三种方法</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#原型，构造函数，实例，原型链" class="sidebar-link">原型，构造函数，实例，原型链</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#instanceof的原理" class="sidebar-link">instanceof的原理</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#new运算符" class="sidebar-link">new运算符</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#面向对象" class="sidebar-link">面向对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#类的声明" class="sidebar-link">类的声明</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#继承" class="sidebar-link">继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#通信类" class="sidebar-link">通信类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#什么是同源策略及限制？" class="sidebar-link">什么是同源策略及限制？</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#前后端如何通信？" class="sidebar-link">前后端如何通信？</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#如何创建ajax？" class="sidebar-link">如何创建Ajax？</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#跨域通信的几种方式！！" class="sidebar-link">跨域通信的几种方式！！</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#安全类" class="sidebar-link">安全类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#csrf" class="sidebar-link">CSRF</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#xss" class="sidebar-link">XSS</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#攻击原理-2" class="sidebar-link">攻击原理</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#防御措施-2" class="sidebar-link">防御措施</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#算法类" class="sidebar-link">算法类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#排序" class="sidebar-link">排序</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#堆栈，队列，链表" class="sidebar-link">堆栈，队列，链表</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#波兰式和逆波兰式" class="sidebar-link">波兰式和逆波兰式</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#渲染机制" class="sidebar-link">渲染机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#doctype" class="sidebar-link">DOCTYPE</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#浏览器渲染过程" class="sidebar-link">浏览器渲染过程</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#重排reflow" class="sidebar-link">重排Reflow</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#重绘repaint" class="sidebar-link">重绘Repaint</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#布局layout" class="sidebar-link">布局Layout</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#js运行机制" class="sidebar-link">JS运行机制</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#页面性能" class="sidebar-link">页面性能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#非核心代码的异步加载" class="sidebar-link">非核心代码的异步加载</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#异步加载区别" class="sidebar-link">异步加载区别</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#浏览器缓存分类" class="sidebar-link">浏览器缓存分类</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#错误监控" class="sidebar-link">错误监控</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#错误分类" class="sidebar-link">错误分类</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#错误的捕获方式" class="sidebar-link">错误的捕获方式</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#上报错误原理" class="sidebar-link">上报错误原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#变量类型和计算" class="sidebar-link">变量类型和计算</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#值类型" class="sidebar-link">值类型</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#类型转换" class="sidebar-link">类型转换</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#类型判断" class="sidebar-link">类型判断</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#变量计算" class="sidebar-link">变量计算</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#js内置函数" class="sidebar-link">Js内置函数</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#内置对象" class="sidebar-link">内置对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#原型和闭包" class="sidebar-link">原型和闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#对象-若干属性的集合" class="sidebar-link">对象--若干属性的集合</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#函数和对象的关系" class="sidebar-link">函数和对象的关系</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#prototype原型" class="sidebar-link">prototype原型</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#proto-隐式原型" class="sidebar-link">_proto_隐式原型</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#instanceof-原理" class="sidebar-link">instanceof 原理</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#继承-2" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#执行上下文" class="sidebar-link">执行上下文</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#this" class="sidebar-link">this</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#call-apply-bind" class="sidebar-link">call,apply,bind</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#this优先级" class="sidebar-link">this优先级</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#原型规则和示例" class="sidebar-link">原型规则和示例</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#原型链-2" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#作用域" class="sidebar-link">作用域</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#作用域链" class="sidebar-link">作用域链</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#闭包" class="sidebar-link">闭包</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#异步和单线程" class="sidebar-link">异步和单线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#内置函数" class="sidebar-link">内置函数</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#日期" class="sidebar-link">日期</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#math" class="sidebar-link">Math</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#dom" class="sidebar-link">DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#dom节点操作" class="sidebar-link">DOM节点操作</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#dom结构操作" class="sidebar-link">DOM结构操作</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#bom" class="sidebar-link">BOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#如何检测浏览器的类型" class="sidebar-link">如何检测浏览器的类型</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#拆解url的拆解" class="sidebar-link">拆解url的拆解</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#事件" class="sidebar-link">事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#事件代理" class="sidebar-link">事件代理</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#ajax" class="sidebar-link">Ajax</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#手写一个ajax" class="sidebar-link">手写一个Ajax</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#状态码说明" class="sidebar-link">状态码说明:</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#跨域" class="sidebar-link">跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#跨域的几种实现方式" class="sidebar-link">跨域的几种实现方式</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#可以跨域的三个标签" class="sidebar-link">可以跨域的三个标签</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#jsonp实现原理" class="sidebar-link">JSONP实现原理</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#服务端跨域" class="sidebar-link">服务端跨域</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#存储" class="sidebar-link">存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#cookie" class="sidebar-link">cookie</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#sessionstorage-locationstorage" class="sidebar-link">sessionStorage,locationStorage</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#区别" class="sidebar-link">区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#页面渲染" class="sidebar-link">页面渲染</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#加载形式" class="sidebar-link">加载形式</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#加载一个资源的过程" class="sidebar-link">加载一个资源的过程</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#浏览器渲染页面的过程" class="sidebar-link">浏览器渲染页面的过程</a></li><li class="sidebar-sub-header"><a href="/pages/Interview/FE_Interview.html#window-onload和domcontentloaded" class="sidebar-link">window.onload和DOMContentLoaded</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>🎮 杂七杂八</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/个人项目.html" class="sidebar-link">🔩项目</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>🎨 其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Rests/chrome.html" class="sidebar-link">🔮 Chrome 技巧</a></li><li><a href="/pages/Rests/git.html" class="sidebar-link">🔮 Git 命令</a></li><li><a href="/pages/Rests/Hexo.html" class="sidebar-link">🔮 Hexo 入门</a></li><li><a href="/pages/Rests/Sublime_Text3.html" class="sidebar-link">🔮 Subleme_text3</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>🎯 周记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Week/weekly_1.html" class="sidebar-link">周记一</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>JavaScript初级面试知识点总结丶
</p> <h1 id="面试必备技巧"><a href="#面试必备技巧" class="header-anchor">#</a> 面试必备技巧</h1> <h2 id="技术栈"><a href="#技术栈" class="header-anchor">#</a> 技术栈</h2> <ul><li>vue，react，Sass，Lass，webpack，gulp</li></ul> <h2 id="页面布局"><a href="#页面布局" class="header-anchor">#</a> 页面布局</h2> <ul><li>浮动</li> <li>flex</li> <li>表格布局</li> <li>绝对定位</li> <li>gird布局</li> <li>总结:两栏布局和三栏布局</li></ul> <h2 id="css盒模型"><a href="#css盒模型" class="header-anchor">#</a> CSS盒模型</h2> <h3 id="两种模型区别"><a href="#两种模型区别" class="header-anchor">#</a> 两种模型区别</h3> <ul><li><p>标准模型:<code>content</code></p></li> <li><p><code>box-sizing:content-box;</code> (默认)
<img src="/JS_Interview/标准盒模型.jpg"></p></li> <li><p>IE模型:<code>border+padding+content</code></p></li> <li><p><code>box-sizing:border-box;</code> <img src="/JS_Interview/IE盒模型.jpg"></p></li></ul> <h3 id="js如何设置获取盒模型对应的宽和高"><a href="#js如何设置获取盒模型对应的宽和高" class="header-anchor">#</a> JS如何设置获取盒模型对应的宽和高</h3> <ul><li><code>dom.style.height/width</code> 只能取内联样式</li> <li><code>dom.currentStyle.width/height</code> 渲染后的宽高,只有IE支持</li> <li><code>window.getComputedStyle(dom).width/height</code> chrome通用性不错</li> <li><code>dom.getBoundingClientRect().width/height</code> 根据视窗决定的绝对位置,左上角</li></ul> <h3 id="bfc"><a href="#bfc" class="header-anchor">#</a> BFC</h3> <ul><li>BFC块级格式化上下文,解决边距重叠</li> <li>IFC内联样式的格式化上下文</li></ul> <ol><li>BFC元素的垂直方向会发生重叠</li> <li>BFC的区域不会与浮动元素重叠</li> <li>BFC元素是个独立的容器,内外互不影响</li> <li>BFC子元素即使是浮动元素也会参与高度计算</li></ol> <h3 id="创建bfc"><a href="#创建bfc" class="header-anchor">#</a> 创建BFC</h3> <ul><li>float的值不为：none</li> <li>position的值不为：relative和static</li> <li>display的值为：table-cell,table-caption和inline-block的任何一个</li> <li>overflow的值为：auto、scroll、hidden</li></ul> <h3 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h3> <ul><li>边距重叠</li> <li>不与float元素重叠</li> <li>父元素高度塌陷，设置BFC父元素高度加上子元素高度</li></ul> <h2 id="dom事件"><a href="#dom事件" class="header-anchor">#</a> DOM事件</h2> <h3 id="dom事件的级别"><a href="#dom事件的级别" class="header-anchor">#</a> dom事件的级别</h3> <ul><li><code>element.onclick = function () {}</code> DOM0级</li> <li><code>element.addEventListener ('click', function () {},false)</code> DOM2级</li> <li><code>element.addEventListener ('keyup', function () {},false)</code> DOM3级 + 鼠标键盘事件</li></ul> <h3 id="dom事件模型"><a href="#dom事件模型" class="header-anchor">#</a> dom事件模型</h3> <ul><li>捕获,冒泡</li></ul> <h3 id="dom事件流"><a href="#dom事件流" class="header-anchor">#</a> dom事件流</h3> <ul><li>捕获--目标阶段--冒泡</li></ul> <h3 id="dom事件捕获流程"><a href="#dom事件捕获流程" class="header-anchor">#</a> dom事件捕获流程</h3> <ul><li><p>window</p></li> <li><p>document</p></li> <li><p>html <code>document.documentElement</code></p></li> <li><p>body <code>document.body</code></p></li> <li><p>冒泡</p></li></ul> <h3 id="event对象的常见应用"><a href="#event对象的常见应用" class="header-anchor">#</a> Event对象的常见应用</h3> <ul><li>阻止默认行为 <code>event.preventDefault()</code></li> <li>阻止冒泡行为 <code>stopPropagation()</code></li> <li>优先级可以让同时绑定的另一个事件不执行 <code>event.stopImmediatePropagation()</code></li> <li>当前事件绑定的对象 <code>event.currentTarget</code></li> <li>目标对象,添加在什么上 <code>event.target</code></li></ul> <h3 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件</h3> <ul><li>Event</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> eve <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span>
ev<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test dispatch'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ev<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>eve<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>CystomEvent</li></ul> <h2 id="http协议"><a href="#http协议" class="header-anchor">#</a> HTTP协议</h2> <h3 id="主要特点"><a href="#主要特点" class="header-anchor">#</a> 主要特点</h3> <ul><li>简单快速: url资源固定</li> <li>灵活: 头部的数据类型,可以变化</li> <li>无连接: 链接一次会断掉,不会保持连接</li> <li>无状态: 客户端服务端是两种身份,两次连接无法区分是否是同一个</li></ul> <h3 id="http报文的组成部分"><a href="#http报文的组成部分" class="header-anchor">#</a> HTTP报文的组成部分</h3> <h4 id="请求报文"><a href="#请求报文" class="header-anchor">#</a> 请求报文</h4> <ul><li>请求行: http方法,页面地址,http协议,以及版本</li> <li>请求头: value值告诉服务端我要的内容</li> <li>空行: 下一个请求体</li> <li>请求体
<img src="/JS_Interview/2.jpg"></li></ul> <h4 id="响应报文"><a href="#响应报文" class="header-anchor">#</a> 响应报文</h4> <ul><li>状态行</li> <li>响应头</li> <li>空行</li> <li>响应体
<img src="/JS_Interview/3.jpg"></li></ul> <h3 id="http方法"><a href="#http方法" class="header-anchor">#</a> HTTP方法</h3> <ul><li>GET 获取资源</li> <li>POST 传输资源</li> <li>HEAD 获得报文首部</li> <li>PUT 更新资源</li> <li>DELETE 删除资源</li></ul> <h3 id="get和push区别"><a href="#get和push区别" class="header-anchor">#</a> GET和PUSH区别</h3> <img src="/JS_Interview/4.jpg"> <ul><li><p>前者浏览器回退无害,后者会再次提交请求</p></li> <li><p>主动缓存,post可手动设置缓存</p></li> <li><p>参数会被完整保留在浏览器历史记录里,post参数不保留</p></li> <li><p>参数长度限制</p></li> <li><p>get参数通过url传递,post放在Request body中</p></li> <li><p>数据类型只接受ASCII</p></li> <li><p>不传递敏感信息</p></li></ul> <h3 id="状态码"><a href="#状态码" class="header-anchor">#</a> 状态码</h3> <h4 id="_1xx"><a href="#_1xx" class="header-anchor">#</a> 1XX</h4> <h2 id="指示信息-表示请求收到-继续处理"><a href="#指示信息-表示请求收到-继续处理" class="header-anchor">#</a> 指示信息--表示请求收到,继续处理</h2> <h4 id="_2xx"><a href="#_2xx" class="header-anchor">#</a> 2XX</h4> <p>成功--表示请求已经被成功接受</p> <ul><li>200 ok: 客户端请求成功</li> <li>206Partial Content: 客户发送了一个带有Range头的GET请求,服务器完成了它</li></ul> <h4 id="_3xx"><a href="#_3xx" class="header-anchor">#</a> 3XX</h4> <p>重定向--要完成请求必须进行进一步的操作</p> <ul><li>301 Moved Permanently: 所请求的页面已经转移至新的url</li> <li>302 Found: 所请求的页面已经临时转移至新的url</li> <li>304 Not Modified: 客户端有缓存的文档并发出了一个条件性的请求,服务器告诉客户,原来缓存的文档还可以继续使用</li> <li></li></ul> <h4 id="_4xx"><a href="#_4xx" class="header-anchor">#</a> 4XX</h4> <p>客户端错误--请求有语法错误或者请求无法实现</p> <ul><li>400 Bad Request: 客户端请求有语法错误,不能被服务器所理解</li> <li>401 Unauthorized: 请求未经授权,这个状态码必须和WWW-Authenticate报头域一起使用</li> <li>403 Forbidden: 对被请求页面的访问被禁止</li> <li>404 Not Found: 请求的资源不存在</li></ul> <h4 id="_5xx"><a href="#_5xx" class="header-anchor">#</a> 5XX</h4> <p>服务器错误--服务器未能实现合法的请求</p> <ul><li>500 Internal Server Error:服务器发生不可预期的错误原来缓存的文档还可以继续使用</li> <li>503 Server Unavailable: 请求未完成,服务器临时过载或当机,一段时间后可能恢复正常</li></ul> <h3 id="持久链接"><a href="#持久链接" class="header-anchor">#</a> 持久链接</h3> <ul><li>1.1版本中</li> <li>Http协议采用 '请求-应答'模式,当使用普通模式,即非Keep-Alive模式时,每个请求/应答客户和服务器都要新建一个连接,完成之后立即断开连接(Http协议为无连接协议)</li> <li>当使用Keep-Alive模式(又称持久连接,连接重用)时,Keep-Alive功能使客户端到服务器端的连接持续有效,当出现对服务器的后即请求时,Keep-Alive功能避免了建立或者重新建立连接</li></ul> <h3 id="管线化"><a href="#管线化" class="header-anchor">#</a> 管线化</h3> <ul><li>持久连接情况下,某个连接上的消息传递类似于:<code>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</code></li> <li>管线化情况下:<code>请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</code></li></ul> <h4 id="管线化特点"><a href="#管线化特点" class="header-anchor">#</a> 管线化特点</h4> <img src="/JS_Interview/5.jpg"> <ul><li>管线化机制通过持久化连接完成,至少HTTP1.1支持此技术</li> <li>get和head可以进行管线化,post则有所限制</li> <li>初次创建连接不启动,因为对方(服务器)不一定支持HTTP/1.1版本协议</li></ul> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <h3 id="创建对象的三种方法"><a href="#创建对象的三种方法" class="header-anchor">#</a> 创建对象的三种方法</h3> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>//	字面量对象
var o1 = {name:'o1'}
//	new object 声明对象
var o2 = new Object(){naem:'o2'}

//显示的构造函数得来创建对象
var M = function (naem) {this.name= name}
var o3 = new M('o3')

//Object.create方法创建
var P = {name:'o4'}
var o4 = Object.create(P)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="原型，构造函数，实例，原型链"><a href="#原型，构造函数，实例，原型链" class="header-anchor">#</a> 原型，构造函数，实例，原型链</h3> <img src="/JS_Interview/原型.jpg">
- 对象就是实例
- 函数的protopype 会初始化一个空对象
- new 函数就是构造函数
- 原型对象的`constructor`指向构造函数
- 对象才有`__proto__`，且指向原型对象
- 函数才有`prototype`
- `M.__proto__ === Function.prototype` M这个普通函数是Function构造函数的实例
<h3 id="instanceof的原理"><a href="#instanceof的原理" class="header-anchor">#</a> instanceof的原理</h3> <ul><li><code>object instanceof constructor</code>	object要检测的对象,constructor某个构造函数</li> <li>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上
<img src="/JS_Interview/原型instanceof.jpg"></li> <li><code>instanceof</code>判断<code>实例对象的__proto__</code>是不是和<code>构造函数的prototype</code>来自同一个引用；</li></ul> <h3 id="new运算符"><a href="#new运算符" class="header-anchor">#</a> new运算符</h3> <ul><li><code>new</code>一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：</li></ul> <ol><li>创建一个空的简单JavaScript对象（即{}）；继承构造函数得原型对象；</li> <li>构造函数被执行，链接该对象（即设置该对象的构造函数）到另一个对象；</li> <li>将步骤1新创建的对象作为this的上下文；</li> <li>如果构造函数返回一个'对象'，那么这个对象会取代整个new出来的结果，</li> <li>如果该函数没有返回对象，那么new出来的结果为步骤1创建的对象。</li></ol> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>var new2 = function (func) {
	var o = Object.create(func.prototype);
	var k = func.call(o);
	if(typeof k === Object'') {
		return k;
	}else{
		return o;
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h2> <h3 id="类的声明"><a href="#类的声明" class="header-anchor">#</a> 类的声明</h3> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>function Animal() {
	this.name = 'Bob';
}

//es6中的class声明

class Animal2 {
	constructor () {
		this.name = name;
	}
}

//实例化
(new Animal(),new Animal2())
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <h4 id="借助构造函数"><a href="#借助构造函数" class="header-anchor">#</a> 借助构造函数</h4> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>function Parent1 () {
	this.name = 'parent1';
}

function Child1() {
	Parent1.call(this)
	this.type = 'child1'
}

原理：改变父级this指向
缺点：不能继承来自原型的属性和方法
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="借助原型链"><a href="#借助原型链" class="header-anchor">#</a> 借助原型链</h4> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>function Parent2 () {
	this.name = 'parent2';
}

function Child2 () {
	this.type = &quot;child2&quot;
}
Child2.prototype = new Parent2();

console.log(new Child2)

原理：原型链Child2.__proto__ === Child2.prototype === Parent2.prototype
缺点：继承的实例对象的值有关联，影响使用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h4> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>function Parent3 () {
	this.name = 'aprent3'
	this.play = [1,2,3]
}


function Child3 () {
	Parent3.call(this)
	this.type = 'child3'
}

Child3.prototype = new Parent3()

var s3 = new Child3()
var s4 = new Child4()

原理：组合
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li>优化1</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>function Parent4() {
	this.name = 'aprent3'
	this.play = [1,2,3]
}

function Child4 () {
	Parent4.call(this)
	this.type = 'child4'
}

Child4.prototype = Parent4.prototype

var s5 = new Child4()
var s6 = new Child4()

原理：s3.__proto__ == Parent4.prototype；s3.__proto__ ==Child4.prototype；Parent4.prototype ==Child4.prototype
优点：Parent4.prototype只是引用，不用执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li>优化2</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>function Parent5() {
	this.name = 'aprent3'
	this.play = [1,2,3]
}

function Child5 () {
	Parent5.call(this)
	this.type = 'child5'
}

Child5.prototype = Object.create(Parent5.prototype)
//通过Object.creact创建一个中间对象，区分两个原型对象，隔离
child5.prototype.constructor = child5;

new s7 = new Child5();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="通信类"><a href="#通信类" class="header-anchor">#</a> 通信类</h2> <h3 id="什么是同源策略及限制？"><a href="#什么是同源策略及限制？" class="header-anchor">#</a> 什么是同源策略及限制？</h3> <ul><li><p>是一个用于隔离潜在恶意文件的关键的安全机制</p></li> <li><p>限制了从一个源加载的文档或脚本如何与来自另一个源的资源进行交互</p></li> <li><p>源：协议，端口，域名	有一个不一样就叫跨域</p></li> <li><p>Cookie，LocalStorage和IndexDB无法读取</p></li> <li><p>DOM无法获取</p></li> <li><p>AJAX请求不能发送</p></li></ul> <h3 id="前后端如何通信？"><a href="#前后端如何通信？" class="header-anchor">#</a> 前后端如何通信？</h3> <ul><li>AJAX	同源</li> <li>WebSocket	不限制同源策略</li> <li>CORS	支持跨域支持同源</li></ul> <h3 id="如何创建ajax？"><a href="#如何创建ajax？" class="header-anchor">#</a> 如何创建Ajax？</h3> <ol><li>XMLHttpRequest对象的工作流程；</li> <li>兼容性的处理</li> <li>事件的触发条件</li> <li>事件的触发顺序</li></ol> <h3 id="跨域通信的几种方式！！"><a href="#跨域通信的几种方式！！" class="header-anchor">#</a> 跨域通信的几种方式！！</h3> <ul><li>JSONP</li> <li>Hash	<code>Hash</code>改变不刷新页面</li> <li>postMessage	来自HTML5</li> <li>WebSocket	不受同源策略影响</li> <li>CORS	理解为支持跨域通信的AJAX</li></ul> <h2 id="安全类"><a href="#安全类" class="header-anchor">#</a> 安全类</h2> <h3 id="csrf"><a href="#csrf" class="header-anchor">#</a> CSRF</h3> <p>跨站请求伪造</p> <h4 id="攻击原理"><a href="#攻击原理" class="header-anchor">#</a> 攻击原理</h4> <img src="/JS_Interview/6.jpg">
- 利用本身漏洞执行一些接口
<h4 id="防御措施"><a href="#防御措施" class="header-anchor">#</a> 防御措施</h4> <ul><li>Token验证		访问或注册网站时，服务器会向本地存储一个Token，当访问接口没有Token不会通过验证！</li> <li>Referer验证	页面来源验证</li> <li>隐藏令牌		类似Token，本质没有区别，区别在使用方式</li></ul> <h3 id="xss"><a href="#xss" class="header-anchor">#</a> XSS</h3> <p>跨域脚本攻击</p> <h3 id="攻击原理-2"><a href="#攻击原理-2" class="header-anchor">#</a> 攻击原理</h3> <ul><li>通过一定渠道向你注入js</li></ul> <h3 id="防御措施-2"><a href="#防御措施-2" class="header-anchor">#</a> 防御措施</h3> <h2 id="算法类"><a href="#算法类" class="header-anchor">#</a> 算法类</h2> <h3 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h3> <ul><li>快速</li> <li>选择</li> <li>希尔</li> <li>冒泡</li></ul> <h3 id="堆栈，队列，链表"><a href="#堆栈，队列，链表" class="header-anchor">#</a> 堆栈，队列，链表</h3> <h3 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h3> <h3 id="波兰式和逆波兰式"><a href="#波兰式和逆波兰式" class="header-anchor">#</a> 波兰式和逆波兰式</h3> <h2 id="渲染机制"><a href="#渲染机制" class="header-anchor">#</a> 渲染机制</h2> <h3 id="doctype"><a href="#doctype" class="header-anchor">#</a> DOCTYPE</h3> <ul><li>DTD告诉浏览器我是什么文档类型</li> <li>DOCTYPE用来声明文档类型和DTD规范</li> <li><code>&lt;!DOCTYPE html&gt;</code></li></ul> <h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="header-anchor">#</a> 浏览器渲染过程</h3> <img src="/JS_Interview/7.jpg"> <ul><li>DOM Tree</li> <li>CSS Tree</li> <li>两个树合并成渲染树</li></ul> <h3 id="重排reflow"><a href="#重排reflow" class="header-anchor">#</a> 重排Reflow</h3> <ul><li>各个元素的盒子模型改变时，需要浏览器根据各种样式来计算并根据计算结果将元素放在他该出现的位置。
<img src="/JS_Interview/8.jpg"></li></ul> <h3 id="重绘repaint"><a href="#重绘repaint" class="header-anchor">#</a> 重绘Repaint</h3> <ul><li>各种css条件都确定后，浏览器按照元素的特性绘制一遍，于是页面的内容出现了，这就是repaint</li> <li>触发条件：DOM改动，CSS改动</li> <li>页面不一样就会repaint</li> <li>尽量少的repaint，把要插入的节点整合为一个节点！</li></ul> <h3 id="布局layout"><a href="#布局layout" class="header-anchor">#</a> 布局Layout</h3> <h2 id="js运行机制"><a href="#js运行机制" class="header-anchor">#</a> JS运行机制</h2> <ul><li>异步</li> <li>单线程</li></ul> <h2 id="页面性能"><a href="#页面性能" class="header-anchor">#</a> 页面性能</h2> <ul><li>资源压缩合并</li> <li>非核心代码的异步加载——&gt;异步加载方式——&gt;异步加载区别</li> <li>利用浏览器缓存——&gt;缓存分类——&gt;缓存原理</li> <li>使用CDN</li> <li>预解析DNS：多个域名</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meat</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>x-dns-prefetch-control<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>on<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- https需要强制打开a标签的预解析 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span> <span class="token attr-value"><span class="token punctuation">=</span> <span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>//host_name_to_prefetch.com<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 预解析 --&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="非核心代码的异步加载"><a href="#非核心代码的异步加载" class="header-anchor">#</a> 非核心代码的异步加载</h3> <ul><li>动态脚本加载</li> <li>defer</li> <li>async</li></ul> <h3 id="异步加载区别"><a href="#异步加载区别" class="header-anchor">#</a> 异步加载区别</h3> <ul><li>defer是在HTML解析完后才会执行，如果是多个，按照加载顺序依次执行</li> <li>async是在加载完成后立即执行，如果是多个，执行顺序和加载顺序无关</li></ul> <h3 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="header-anchor">#</a> 浏览器缓存分类</h3> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h4> <ul><li>直接使用缓存文件，不询问</li> <li>Expires 绝对时间</li> <li>Cache-Control <code>Cache-Control:max-mag=3600</code>	相对时间</li> <li>两者都有以相对时间为准</li> <li>时间不到不用再次请求。</li></ul> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <ul><li>询问是否使用缓存文件</li> <li>Last-Modifiedd If-Modified-Since</li> <li>Etag  If-None-Match</li></ul> <h2 id="错误监控"><a href="#错误监控" class="header-anchor">#</a> 错误监控</h2> <h3 id="错误分类"><a href="#错误分类" class="header-anchor">#</a> 错误分类</h3> <ul><li>资源加载错误</li> <li>即时运行错误：代码错误</li></ul> <h3 id="错误的捕获方式"><a href="#错误的捕获方式" class="header-anchor">#</a> 错误的捕获方式</h3> <ul><li>window.onerror只能捕获即时运行错误</li> <li>try..catch</li></ul> <h4 id="资源加载错误的捕获！！重点"><a href="#资源加载错误的捕获！！重点" class="header-anchor">#</a> 资源加载错误的捕获！！重点</h4> <ul><li>object.onerror 不会冒泡！所以window失效！</li> <li>performance.getEntries() 获取所有已加载资源的加载时长</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>performance.getEntries().forEach(item=&gt;{console.log(item.name)})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>Error事件捕获</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>window.adddEventList('error',function(e) {
	cosnole.log('捕获'，e)
},true)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="跨域错误"><a href="#跨域错误" class="header-anchor">#</a> 跨域错误</h4> <ul><li><p>错误信息：Script error</p></li> <li><p>错误详情：null</p></li> <li><p>客户端：在script标签上增加：crossorigin属性</p></li> <li><p>服务端：设置js资源响应头Access-Control_allow-Origin:*(或者域名)</p></li></ul> <h3 id="上报错误原理"><a href="#上报错误原理" class="header-anchor">#</a> 上报错误原理</h3> <ul><li>采用Ajax通信的方式上班</li> <li>利用Image对象上报</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>(new Image()).src = 'http://baidu.com/test?r=test'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="变量类型和计算"><a href="#变量类型和计算" class="header-anchor">#</a> 变量类型和计算</h2> <h3 id="值类型"><a href="#值类型" class="header-anchor">#</a> 值类型</h3> <p>存储方式来分:</p> <ol><li>引用:对象,数组,函数,null</li> <li>基本:boolean,string,number,undefined</li> <li>typeof操作符可以判断--&gt;undefined,Boolean,string,number,object,function.</li></ol> <h3 id="类型转换"><a href="#类型转换" class="header-anchor">#</a> 类型转换</h3> <img src="/JS_interiew/lxzh.webp"> <h3 id="类型判断"><a href="#类型判断" class="header-anchor">#</a> 类型判断</h3> <ul><li>值类型的类型判断用typeof，引用类型的类型判断用instanceof
<img src="/JS_interiew/类型判断.webp"></li></ul> <h3 id="变量计算"><a href="#变量计算" class="header-anchor">#</a> 变量计算</h3> <ol><li>字符串拼接</li> <li>== 运算符</li> <li>if语句</li> <li>逻辑运算</li></ol> <h3 id="js内置函数"><a href="#js内置函数" class="header-anchor">#</a> Js内置函数</h3> <ul><li>object</li> <li>Array</li> <li>Function</li></ul> <h3 id="内置对象"><a href="#内置对象" class="header-anchor">#</a> 内置对象</h3> <ul><li>Math</li> <li>Json</li></ul> <h2 id="原型和闭包"><a href="#原型和闭包" class="header-anchor">#</a> 原型和闭包</h2> <h3 id="对象-若干属性的集合"><a href="#对象-若干属性的集合" class="header-anchor">#</a> 对象--若干属性的集合</h3> <ul><li>数组是对象，函数是对象，对象还是对象;(一切（引用类型）都是对象)</li> <li>对象里面的一切都是属性，只有属性，没有方法</li></ul> <h3 id="函数和对象的关系"><a href="#函数和对象的关系" class="header-anchor">#</a> 函数和对象的关系</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>var fn = function () { };
console.log(fn instanceof Object);  // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><code>对象都是通过函数来创建的</code></li></ul> <h3 id="prototype原型"><a href="#prototype原型" class="header-anchor">#</a> prototype原型</h3> <ul><li>prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性
<img src="/JS_interiew/prototype.png"></li> <li>每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。</li> <li>即：<code>fn.__proto__ === Fn.prototype</code></li> <li>这里的<code>__proto__</code>成为&quot;隐式原型&quot;&quot;</li></ul> <h3 id="proto-隐式原型"><a href="#proto-隐式原型" class="header-anchor">#</a> __proto__隐式原型</h3> <img src="/JS_interiew/隐式原型.png">
- 即，每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。
- 自定义函数的prototype本质上就是和 `var obj = {}` 是一样的，
- 都是被Object创建，所以它的`__proto__`指向的就是Object.prototype。
- 但是`Object.prototype`确实一个特例——它的`__proto__`指向的是`null`，切记切记！
<img src="/JS_interiew/隐式原型null.png">
- 函数是被Function创建的
<img src="/JS_interiew/环形结构.png">
- Function.prototype指向的对象，它的`__proto__`是不是也指向Object.prototype？
<img src="/JS_interiew/f--o.png"> <h3 id="instanceof-原理"><a href="#instanceof-原理" class="header-anchor">#</a> instanceof 原理</h3> <img src="/JS_interiew/instanceof运用.png">
- 上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？！
- 为什么过会儿再说，先把instanceof判断的规则告诉大家:
<img src="/JS_interiew/instanceof原理.png">
  1. Instanceof的判断队则是：沿着A的`__proto__`这条线来找，
  2. 同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，
  3. 即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。
  4. `instanceof`表示的就是一种继承关系，或者原型链的结构
  5. Symbol.hasInstance 自定义 instanceof 行为判断引用类型属于哪一个构造函数的方法;
  6. `f.隐示是否等于Foo.显示原型`
<p>所有合成整体为：
<img src="/JS_interiew/原型链.png"></p> <h3 id="继承-2"><a href="#继承-2" class="header-anchor">#</a> 继承</h3> <ul><li>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链
<img src="/JS_interiew/继承.png"></li> <li><code>HasOwnproPerty</code>:区分一个属性到底是基本的还是从原型中</li> <li>HasOwnproPerty 来自 <code>Object.prototype</code></li></ul> <h4 id="原型的灵活性"><a href="#原型的灵活性" class="header-anchor">#</a> 原型的灵活性</h4> <ol><li>首先,对象属性可以随时改变</li> <li>其次,如果继承的方式不合适,可以做出修改</li> <li>最后,当前缺少你要实用的方法,可以自己去创建</li></ol> <ul><li>如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</li></ul> <h3 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h3> <p>三种数据的准备情况</p> <ol><li>变量、函数表达式--变量声明，默认赋值为undefined；</li> <li>this--赋值；</li> <li>函数声明--赋值；</li></ol> <h4 id="全局代码的上下文环境数据内容"><a href="#全局代码的上下文环境数据内容" class="header-anchor">#</a> 全局代码的上下文环境数据内容</h4> <ul><li>函数:函数每被调用一次，都会产生一个新的执行上下文环境</li> <li>给执行上下文环境下一个通俗的定义----在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空</li></ul> <ol><li>普通变量（包括函数表达式），如： var a = 10--- 声明（默认赋值为undefined;</li> <li>函数声明，如： function fn() { }--- 赋值</li> <li>this--- 赋值
函数体:</li> <li>参数-- 赋值</li> <li>arguments-- 赋值</li> <li>自由变量的取值作用域-- 赋值</li></ol> <h3 id="this"><a href="#this" class="header-anchor">#</a> this</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ol><li>直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window</li> <li>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象</li> <li>对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this
<img src="/JS_interiew/this.webp">[]</li></ol> <h4 id="构造函数执行"><a href="#构造函数执行" class="header-anchor">#</a> 构造函数执行</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Foo() {
	this.name = 'wangfupeng';
	this.year = 1998;
	
	console.log(this); Foo{name:&quot;wangfupeng&quot;,year:1998}
}
var f1 = new Foo();

console.log(f1.name)
console.log(f1.year);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>函数名首字母大写</li> <li>instanceof 判断函数是否是一个变量的构造函数</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = {} ==&gt;var a = new Object()
var a = [] ==&gt;var a = newArray()
function Foo() {...} 是 var Foo = new Function(...)
instaanceof Array 判断是否是数组;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="函数作为对象的一个属性"><a href="#函数作为对象的一个属性" class="header-anchor">#</a> 函数作为对象的一个属性</h4> <ul><li>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {
	x:10,
	fn:function() {
		console.log(this) //Object {x:10;fn:function()}
		console.log(this.x) //10
		}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>注意，如果fn函数不作为obj的一个属性被调用，会是什么结果呢？</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {
	x:10,
	fn:function() {
		console.log(this) // window{}
		console.log(this.x) // undefind
 }
}
var fn1=obj.fn;
fn1()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="函数用call或者apply调用"><a href="#函数用call或者apply调用" class="header-anchor">#</a> 函数用call或者apply调用</h4> <ul><li>当一个函数被call和apply调用时，this的值就取传入的对象的值。</li></ul> <h4 id="全局-调用普通函数"><a href="#全局-调用普通函数" class="header-anchor">#</a> 全局 &amp; 调用普通函数</h4> <h3 id="call-apply-bind"><a href="#call-apply-bind" class="header-anchor">#</a> call,apply,bind</h3> <ul><li>.bind()必须是一个函数表达式;</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>function fn1(name,age) {
	alert(name);
	console.log(this);
}
fn1.call({x:100},'zhangsan',20)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>bind 这些改变上下文的 API,对于这些函数来说，this 取决于第一个参数</li> <li>如果第一个参数为空，那么就是 window</li></ul> <h3 id="this优先级"><a href="#this优先级" class="header-anchor">#</a> this优先级</h3> <ol><li>new 的方式优先级最高;</li> <li>接下来是 bind 这些函数;</li> <li>然后是 obj.foo() 这种调用方式;</li> <li>最后是 foo 这种调用方式;</li> <li>箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</li></ol> <h3 id="原型规则和示例"><a href="#原型规则和示例" class="header-anchor">#</a> 原型规则和示例</h3> <ul><li>所有引用类型(数组对象函数)都具有对象特性,即可自由拓展属性,(null除外)</li> <li>所有的引用类型都有一个_proto_(隐示原型)属性,属性值是一个普通对象.</li> <li>所有的函数都有prototype属性(),.....普通对象</li> <li>所有的引用类型(,,),_proto_属性值都指向他的构造函数&quot;prototype&quot;属性值</li> <li>当试图找到一个对象(引用类型),的某个属性时,如果本身没有,那么就会去他的__proto__中寻找(prototype)</li></ul> <h3 id="原型链-2"><a href="#原型链-2" class="header-anchor">#</a> 原型链</h3> <img src="/JS_interiew/原型链.png"> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <ul><li>没有块作用域</li> <li>只有函数和全局作用域</li></ul> <h3 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h3> <ul><li><p>自由变量:当前作用域没有定义的变量;</p></li> <li><p>Object 是所有对象的父级，所有对象都可以通过 <strong>proto</strong> 找到它</p></li> <li><p>Function 是所有函数的父级，所有函数都可以通过 <strong>proto</strong> 找到它</p></li> <li><p>函数的 prototype 是一个对象</p></li> <li><p>对象的 <strong>proto</strong> 属性指向原型， <strong>proto</strong> 将对象和原型连接起来组成了原型链</p></li></ul> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p>闭包：是指有权访问另一个函数作用域中的变量的函数,就是发生了闭包</p> <p>使用场景:</p> <ul><li>函数作为返回值</li> <li>函数作为参数传递
作用：封装变量收敛权限!!</li> <li>都是从定义时候的作用域里面去执行；</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>function F1() {
  var a = 100;
  return function () {
    console.log(a);//自由变量,父级作用域寻找
  }
}
var  f1= F1()
var a =200
f1()//100

//作为参数传递
function F1() {
  var a = 100;
  return function () {
    console.log(a);//自由变量,父级作用域寻找
  }
}
var f1 = F1();

function F2(f1){
  var a = 200;
  fn()
}
F2(f1)//100
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="异步和单线程"><a href="#异步和单线程" class="header-anchor">#</a> 异步和单线程</h2> <p>什么时候需要异步？</p> <ul><li>可能发生等待</li> <li>等待中不能像alert()一样阻塞程序运行</li> <li>所有的&quot;等待的情况&quot;都需要异步</li></ul> <p>异步的使用场景?</p> <ul><li>定时任务:setTimeout,setInverval</li> <li>网络请求:ajax请求,动态加载</li> <li>事件绑定；</li></ul> <p>同步和异步的区别?</p> <ul><li>同步会阻塞代码执行,而异步不会;</li> <li>alert是同步,setTimeout是异步;</li></ul> <h3 id="内置函数"><a href="#内置函数" class="header-anchor">#</a> 内置函数</h3> <h3 id="日期"><a href="#日期" class="header-anchor">#</a> 日期</h3> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>Date.now()//获取当前时间毫秒数
var dt = new Date()
te.getTime()//获取毫秒数
te.getFullYear()//年
te.getMonth()//月(0-11)
te.getDate()//日(1-31)
te.getHoures()//小时 (0-23)
te.getMinutes()//分钟(0-59)
te.getSeconds()//秒(0-59)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="math"><a href="#math" class="header-anchor">#</a> Math</h3> <ul><li>Math.random();作用于清除缓存</li></ul> <p>数组API</p> <ul><li>forEach遍历所有元素</li> <li>every 判断所有元素是否都符合条件</li> <li>some 判断只要有一个符合条件</li> <li>map 对元素重新组装,生成新的数组</li> <li>sort 排序</li> <li>filter 过滤符合条件的元素</li></ul> <p>对象API</p> <ul><li>for in</li> <li></li></ul> <h2 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h2> <h3 id="dom节点操作"><a href="#dom节点操作" class="header-anchor">#</a> DOM节点操作</h3> <ul><li>获取节点:</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>document.getElementById('div')//元素
document.getElementaByTagName('div')//集合
document.getElementaByClassName('.container')//集合
document.querySelectorAll('p')//集合
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>Attribute:修改HTML属性的修改和获取</li> <li>property:Js对象的标准属性</li></ul> <h3 id="dom结构操作"><a href="#dom结构操作" class="header-anchor">#</a> DOM结构操作</h3> <ul><li>新增节点:</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>document.createElement('p')//创建元素节点
document.appendChild(p1)//添加新创建的元素
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>获取子元素</li></ul> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>var parent = div.parentElement;
var child = div.childNodes;//集合
div.removeChild(child[0]);//删除子元素
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="bom"><a href="#bom" class="header-anchor">#</a> BOM</h2> <h3 id="如何检测浏览器的类型"><a href="#如何检测浏览器的类型" class="header-anchor">#</a> 如何检测浏览器的类型</h3> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>navigator.userAgent
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="拆解url的拆解"><a href="#拆解url的拆解" class="header-anchor">#</a> 拆解url的拆解</h3> <div class="language-es6 line-numbers-mode"><pre class="language-text"><code>location.href //整个地址可改变或者赋值
location.host //域
location.pathname
location.search
location.hash
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h2> <ul><li>通用事件绑定</li> <li>冒泡</li></ul> <h3 id="事件代理"><a href="#事件代理" class="header-anchor">#</a> 事件代理</h3> <ul><li>代码简洁</li> <li>减少浏览器占用</li></ul> <h2 id="ajax"><a href="#ajax" class="header-anchor">#</a> Ajax</h2> <ul><li>XMLHttpRequest</li></ul> <h3 id="手写一个ajax"><a href="#手写一个ajax" class="header-anchor">#</a> 手写一个Ajax</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>	&lt;script&gt;
		var xhr = new new XMLHttpRequest()
		xhr.open(&quot;GET&quot;,&quot;api&quot;,false) 
		xhr.onreadystatechange = function () {
			//这里的函数异步执行
			if(xhr.readyState == 4) {
				if (xhr.status == 200) {
					alert(xhr.responseText)
				}
			}
		}
		xhr.send(null)
	&lt;/script&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="状态码说明"><a href="#状态码说明" class="header-anchor">#</a> 状态码说明:</h3> <p>readyState:</p> <ul><li>0 (未初始化)  还没有调用send()方法</li> <li>1 (载入) 异地哦阿勇send()方法 正在发送请求</li> <li>2 (载入完成) send() 方法执行完成, 已经接收到全部响应内容</li> <li>3(交互) 正在解析响应内容</li> <li>4(完成) 响应内容解析完成,可以在客户端调用</li></ul> <p>状态码</p> <ul><li>2xx 表示成功处理请求,如200</li> <li>3xx 需要重定向,浏览器直接跳转</li> <li>4xx 客户端错误,如404</li> <li>5xx 服务端错误</li></ul> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <p>注意事项:</p> <ul><li>所有的跨域请求都必须经过信息提供方允许</li> <li>如果未经允许即可获取,则是浏览器同源策略出现漏洞</li></ul> <h3 id="跨域的几种实现方式"><a href="#跨域的几种实现方式" class="header-anchor">#</a> 跨域的几种实现方式</h3> <p>什么是跨域?</p> <ul><li>浏览器同源策略,不允许Ajax访问其他域的接口</li> <li>跨域条件:协议,域名,端口,有一个不同就叫跨域</li></ul> <h3 id="可以跨域的三个标签"><a href="#可以跨域的三个标签" class="header-anchor">#</a> 可以跨域的三个标签</h3> <ul><li><code>&lt;img src=xxx&gt;</code> 运用打点统计,统计网站可能是其他域</li> <li><code>&lt;link href=xxx&gt;</code>可以使用CDN,cdn也使其他的域</li> <li><code>&lt;script src=xxx/&gt;</code> 可以使用CDN,cdn也使其他的域</li></ul> <h3 id="jsonp实现原理"><a href="#jsonp实现原理" class="header-anchor">#</a> JSONP实现原理</h3> <ul><li>加载http://coding.m.imooc.com/classindex.html</li> <li>不一定服务器真正的有一个classindex.html文件</li> <li>服务器可以根据请求,动态生成一个文件,返回</li> <li>同理于<code>&lt;script src=&quot;http://coding.m.imooc.com/api.js&quot;/&gt;</code></li></ul> <h3 id="服务端跨域"><a href="#服务端跨域" class="header-anchor">#</a> 服务端跨域</h3> <p>设置http header；</p> <h2 id="存储"><a href="#存储" class="header-anchor">#</a> 存储</h2> <h3 id="cookie"><a href="#cookie" class="header-anchor">#</a> cookie</h3> <ul><li>本身用于客户端和服务器端通信</li> <li>但是它有本地存储的功能,于是就被'借用'来存储</li> <li>使用document.cookie = ...获取和修改即可</li></ul> <p>缺点:</p> <ul><li>存储太小只有4KB;</li> <li>所有的http 请求都带着,会影响获取资源的效率</li> <li>API简单,需要封装才可以用 document.cookie =...</li></ul> <h3 id="sessionstorage-locationstorage"><a href="#sessionstorage-locationstorage" class="header-anchor">#</a> sessionStorage,locationStorage</h3> <ul><li>HTML5专门为存储设计,最大容量5M</li> <li>api简单易用</li> <li>localStorage.setItem(key,value)	存</li> <li>localStorage.getItem(key)	修改和新增</li></ul> <p>区别:</p> <ul><li>都可以存储到本地</li> <li>浏览器关了就会清除sessionStorage,另一个不会</li></ul> <p>注意:</p> <ul><li>ios safari 隐藏模式下</li> <li>localStorage.getItem会报错</li> <li>建议统一使用try-catch封装</li></ul> <h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <ul><li>容量</li> <li>是否携带到ajax中</li> <li>api易用性</li></ul> <h2 id="页面渲染"><a href="#页面渲染" class="header-anchor">#</a> 页面渲染</h2> <h3 id="加载形式"><a href="#加载形式" class="header-anchor">#</a> 加载形式</h3> <ul><li>输入url,加载html</li> <li>加载html中的静态资源:图片,视频...</li></ul> <h3 id="加载一个资源的过程"><a href="#加载一个资源的过程" class="header-anchor">#</a> 加载一个资源的过程</h3> <p>url到html的详细过程</p> <ul><li>浏览器根据DNS服务器得到域名的IP地址</li> <li>向这个IP的机器发送http或https</li> <li>服务器收到,处理并返回http请求</li> <li>浏览器得到返回内容</li></ul> <h3 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="header-anchor">#</a> 浏览器渲染页面的过程</h3> <ul><li>根据HTMl结构生成DOM Tree(dom树)</li> <li>根据CSS生成CSSOM 结构化处理(样式)</li> <li>将DOM和CSSOM整合形成RenderTree(渲染树)</li> <li>根据RenderTree 开始渲染和展示</li> <li>遇到script时,会执行并阻塞渲染</li></ul> <h3 id="window-onload和domcontentloaded"><a href="#window-onload和domcontentloaded" class="header-anchor">#</a> window.onload和DOMContentLoaded</h3> <ul><li>页面的全部资源加载完才执行,包括图片视频</li> <li>DOM渲染完即可执行,此时图片和视频还没有加载完全</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/Node/Node.js.html" class="prev">
        💣 Node.js
      </a></span> <span class="next"><a href="/pages/个人项目.html">
        🔩项目
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bcb09fd0.js" defer></script><script src="/assets/js/2.0cae008b.js" defer></script><script src="/assets/js/15.87afaf84.js" defer></script>
  </body>
</html>
